%option noyywrap

D [0-9]
W [a-zA-Z]

Alphanum ({D}|{W})

%{
#include "Tokens.h"
int yyerror(char *);
int tokenCount;
%}

%%


"["     {tokenCount++; return _LBRACK; }
"]"     {tokenCount++; return _RBRACK; }	
"("					{tokenCount++; return _LPAREN; }
")"					{tokenCount++; return _RPAREN; }
";"					{tokenCount++; return _SEMI; }
":"					{tokenCount++; return _COLON; }
","					{tokenCount++; return _COMMA; }
":="				{tokenCount++; return _ASSIGN; }
"+"					{tokenCount++; return _PLUS; }
"-"					{tokenCount++; return _MINUS; }
"*"					{tokenCount++; return _MULT; }
"/"					{tokenCount++; return _DIVIDE; }
"="					{tokenCount++; return _EQL; }
"<"					{tokenCount++; return _LESS; }
">"					{tokenCount++; return _GTR; }
"<="				{tokenCount++; return _LEQ; }
">="				{tokenCount++; return _GEQ; }
"<>"				{tokenCount++; return _NEQ; }
program				{tokenCount++; return _PROGRAM; }
endvars				{tokenCount++; return _ENDVARS; }
endprocs			{tokenCount++; return _ENDPROCS; }
variables			{tokenCount++; return _VARS; }
novariables			{tokenCount++; return _NOVARS; }
integer				{tokenCount++; return _INTEGER; }
real				{tokenCount++; return _REAL; }
string				{tokenCount++; return _STRING; }
procedures			{tokenCount++; return _PROCS; }
noprocedures		{tokenCount++; return _NOPROCS; }
procedure			{tokenCount++; return _PROC; }
begin				{tokenCount++; return _BEGIN; }
end					{tokenCount++; return _END; }
for					{tokenCount++; return _FOR; }
to					{tokenCount++; return _TO; }
do					{tokenCount++; return _DO; }
if					{tokenCount++; return _IF; }
then				{tokenCount++; return _THEN; }
else				{tokenCount++; return _ELSE; }
read				{tokenCount++; return _READ; }
write       		{tokenCount++; return _WRITE; }
.       {yyerror("Error");}
%%


int yyerror(char * errormsg)
{
	fprintf(stderr, "%s\n", errormsg);
	exit(1);
}